import UIKit

typealias DownloadCallback = (Bool, Any?) -> Void
typealias DownloadProgressCallback = (Float, Any?) -> Void

enum DownloadType {
    case Image, Other
}

enum CacheType {
    case Memory, Disk
}

class DownloadHelper: NSObject {

    static let sharedInstance : DownloadHelper = {
        let instance = DownloadHelper()
        return instance
    }()
    
    var activeDownloads = [String: Download]()
    
    lazy var downloadsSession: URLSession = {
        let configuration = URLSessionConfiguration.background(withIdentifier: "bgSessionConfiguration")
        let session = URLSession(configuration: configuration, delegate: self, delegateQueue: nil)
        return session
    }()
    
    lazy var memoryCache = NSCache<NSString, AnyObject>()
    var cacheType = CacheType.Memory
    var maxCache: UInt = 1000 {
        didSet {
            self.memoryCache.totalCostLimit = Int(maxCache)
        }
    }
    
    // MARK: Download methods
    func startDownloadImage(_ urlString: String, callBack: @escaping DownloadCallback, progressCallBack: DownloadProgressCallback? = nil) {
        startDownload(urlString, downloadType: .Image, callBack: callBack, progressCallBack: progressCallBack)
    }
    
    // Called when the Download button for a track is tapped
    func startDownload(_ urlString: String, downloadType: DownloadType = .Other, callBack: @escaping DownloadCallback, progressCallBack: DownloadProgressCallback? = nil) {
        if let url = URL(string: urlString) {
            if let download = activeDownloads[urlString] {
                download.requestCount += 1
            } else {
                let download = Download(url: urlString)
                download.isDownloading = true
                download.callBack = callBack
                download.progressCallBack = progressCallBack
                download.type = downloadType
                
                activeDownloads[download.url] = download
                
                if isFileCached(urlString: urlString) {
                    finishDownload(urlString)
                } else {
                    download.downloadTask = downloadsSession.downloadTask(with: url)
                    download.downloadTask!.resume()
                }
            }
        }
    }
    
    // Called when the Pause button for a track is tapped
    func pauseDownload(_ urlString: String) {
        if let download = activeDownloads[urlString], download.isDownloading {
            download.downloadTask?.cancel { data in
                if data != nil {
                    download.resumeData = data
                }
            }
            download.isDownloading = false
        }
    }
    
    // Called when the Cancel button for a track is tapped
    func cancelDownload(_ urlString: String) {
        if let download = activeDownloads[urlString] {
            download.requestCount -= 1
            if download.requestCount <= 0 {
                download.downloadTask?.cancel()
                activeDownloads[urlString] = nil
            }
        }
    }
    
    // Called when the Resume button for a track is tapped
    func resumeDownload(_ urlString: String) {
        if let download = activeDownloads[urlString] {
            if let resumeData = download.resumeData {
                download.downloadTask = downloadsSession.downloadTask(withResumeData: resumeData)
                download.downloadTask!.resume()
                download.isDownloading = true
            } else if let url = URL(string: download.url) {
                download.downloadTask = downloadsSession.downloadTask(with: url)
                download.downloadTask!.resume()
                download.isDownloading = true
            }
        }
    }
    
    // MARK: Download helper methods
    
    // This method generates a permanent local file path to save a track to by appending
    // the lastPathComponent of the URL (i.e. the file name and extension of the file)
    // to the path of the appâ€™s Documents directory.
    fileprivate func localFilePathForUrl(_ previewUrl: String) -> URL? {
        let documentsPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0] as NSString
        
        let url = URL(string: previewUrl)
        if let lastPathComponent = url?.lastPathComponent {
            let fullPath = documentsPath.appendingPathComponent(lastPathComponent)
            return URL(fileURLWithPath:fullPath)
        }
        return nil
    }
    
    // This method checks if the local file exists at the path generated by localFilePathForUrl(_:)
    fileprivate func localFileExistsForTrack(_ urlString: String) -> Bool {
        if let localUrl = localFilePathForUrl(urlString) {
            var isDir: ObjCBool = false
            let path = localUrl.path
            return FileManager.default.fileExists(atPath: path, isDirectory: &isDir)
        }
        return false
    }

}

// MARK: - NSURLSessionDelegate

extension DownloadHelper: URLSessionDelegate {
    
    func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
        if let appDelegate = UIApplication.shared.delegate as? AppDelegate {
            if let completionHandler = appDelegate.backgroundSessionCompletionHandler {
                appDelegate.backgroundSessionCompletionHandler = nil
                DispatchQueue.main.async(execute: {
                    completionHandler()
                })
            }
        }
    }
    
}

// MARK: - NSURLSessionDownloadDelegate

extension DownloadHelper: URLSessionDownloadDelegate {
    
    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {
        storeDownload(downloadTask: downloadTask, didFinishDownloadingTo: location)
        if let url = downloadTask.originalRequest?.url?.absoluteString {
            finishDownload(url)
        }
    }
    
    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {
        if let downloadUrl = downloadTask.originalRequest?.url?.absoluteString,
            let download = activeDownloads[downloadUrl] {
            download.progress = Float(totalBytesWritten)/Float(totalBytesExpectedToWrite)
            DispatchQueue.main.async(execute: {
                download.progressCallBack?(download.progress, nil)
            })
        }
    }
    
}

// MARK: - Download Finish procress
extension DownloadHelper {
    
    fileprivate func storeDownload(downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {
        if let originalURL = downloadTask.originalRequest?.url?.absoluteString,
            let destinationURL = localFilePathForUrl(originalURL) {
            
            if cacheType == .Disk {
                print(destinationURL)
                
                let fileManager = FileManager.default
                do {
                    try fileManager.removeItem(at: destinationURL)
                } catch {
                    // Non-fatal: file probably doesn't exist
                }
                do {
                    try fileManager.copyItem(at: location, to: destinationURL)
                } catch let error as NSError {
                    print("Could not copy file to disk: \(error.localizedDescription)")
                }
            } else if cacheType == .Memory {
                if let data = try? Data(contentsOf: location) {
                    memoryCache.setObject(data as AnyObject, forKey: originalURL as NSString)
                }
            }
            
        }
        
    }
    
    fileprivate func finishDownload(_ url: String) {
        if cacheType == .Disk {
            let destinationURL = localFilePathForUrl(url)
            let download = activeDownloads[url]
            if download?.type == .Image {
                let image = UIImage(contentsOfFile: destinationURL?.path ?? "")
                DispatchQueue.main.async(execute: {
                    download?.callBack?(true, image)
                })
            } else {
                if let destinationURL = destinationURL {
                    download?.callBack?(true, try? Data(contentsOf: destinationURL))
                }
            }
            activeDownloads[url] = nil
        } else if cacheType == .Memory {
            if let data = memoryCache.object(forKey: url as NSString) as? Data {
                let download = activeDownloads[url]
                if download?.type == .Image {
                    let image = UIImage(data: data)
                    DispatchQueue.main.async(execute: {
                        download?.callBack?(true, image)
                    })
                } else {
                    download?.callBack?(true, data)
                }

            }
        }
    }
    
    fileprivate func isFileCached(urlString: String) -> Bool {
        if cacheType == .Disk {
            return FileManager.default.fileExists(atPath: localFilePathForUrl(urlString)?.path ?? "")
        } else {
            return memoryCache.object(forKey: urlString as NSString) != nil
        }
    }

}
